 (ns hupo.main
   (:require ["package:flutter/material.dart" :as m]
             ["package:flutter/widgets.dart" :as w]
             ["dart:async" :as async]
             ["dart:io" :as io]
             ["package:flutter/scheduler.dart" :as sched]
             [cljd.flutter :as f]))

(def initial-state
  {:pawns           {:white {:a [0 0]
                             :b [1 0]
                             :c [2 0]}
                     :black {:a [0 4]
                             :b [1 4]
                             :c [2 4]}}
   :selected-pawn   nil
   :last-moved-pawn nil
   :fixed-pawn      nil
   :ai-player       :black
   :ai-enabled      true #_false
   :current-player  :white
   :turn-phase      :designated-move
   :winner-pawn     nil
   :turn-finished        {:white false
                          :black false}
   :turn-no         1})

(def state
  (atom {}))

(def board-size-x 3)
(def board-size-y 5)
(def cell-size 80)

(defn cell-widget [pos]
  (let [abyss [1 2]
        black-target [1 1]
        white-target [1 3]
        border-width 1.0
        border-color m/Colors.black]
    (w/Container
     .width  cell-size
     .height cell-size
     .decoration (w/BoxDecoration
                  .color (condp = pos
                           abyss m/Colors.grey.shade400
                           black-target m/Colors.grey
                           white-target m/Colors.grey
                           m/Colors.grey)
                  .border (w/Border
                           .top (w/BorderSide .width border-width .color border-color)
                           .bottom (w/BorderSide .width border-width .color border-color)
                           .left (w/BorderSide .width border-width .color border-color)
                           .right (w/BorderSide .width border-width .color border-color)))
     .child (if (#{black-target white-target} pos)
              (w/Center .child (m/Text
                                "Î»"
                                .style (m/TextStyle
                                        .fontWeight m/FontWeight.bold
                                        .color (if (= black-target pos)
                                                 m/Colors.black
                                                 m/Colors.green.shade600)
                                        .fontSize 25)))
              (w/Container)))))

(defn get-pawn-position [pawns selected-pawn]
  (let [[color id] selected-pawn]
    (get-in pawns [color id])))

(defn increase-turn-no [state]
  (if (and (-> state :turn-finished :white)
           (-> state :turn-finished :black))
    (-> state
        (update :turn-no inc)
        (assoc :turn-finished {:white false :black false}))
    state))

(defn check-winning-pawn [state]
  (let [{:keys [current-player pawns]} state
        current-pawns (get pawns current-player)
        winning-pos (if (= current-player :white)
                      [1 3]
                      [1 1])]
    (reduce (fn [s [id pos]]
              (if (= pos winning-pos)
                (assoc s :winner-pawn [current-player id])
                s))
            state
            current-pawns)))

(defn valid-tile? [pawns x y]
  (and (>= x 0) (< x board-size-x)
       (>= y 0) (< y board-size-y)
       (not (= [1 2] [x y]))
       (not (some (fn [[_ positions]]
                    (some (fn [[_ [px py]]]
                            (and (= px x) (= py y)))
                          positions))
                  pawns))))

(defn get-valid-tile [x y selected-pawn pawns]
  (let [[sx sy] (get-pawn-position pawns selected-pawn)]
    (when (and (or (and (<= (abs (- x sx)) 1)
                        (<= (abs (- y sy)) 0.5))
                   (and (<= (abs (- x sx)) 0.5)
                        (<= (abs (- y sy)) 1)))
               (valid-tile? pawns x y))
      [x y])))

(defn get-valid-moves [pawns x y]
  (let [possible-moves [[0 1] [0 -1] [1 0] [-1 0]]]
    (->> possible-moves
         (map (fn [[dx dy]] [(+ x dx) (+ y dy)]))
         (filter (fn [pm] (apply #(valid-tile? pawns %1 %2) pm))))))

(defn remove-blocked-pawn [{:keys [selected-pawn pawns] :as state}]
  (let [[sx sy] (get-in pawns selected-pawn)
        [color id] selected-pawn
        valid-moves (get-valid-moves pawns sx sy)]
    (if (empty? valid-moves)
      (-> state
          (update-in [:pawns color] dissoc id)
          (assoc :selected-pawn nil)
          (assoc :fixed-pawn nil))
      state)))

(defn change-turn [state]
  (let [color (:current-player state)
        opposite-color (if (= color :white) :black :white)]
    (-> state
        (assoc :current-player opposite-color)
        (assoc-in [:turn-finished color] true)
        (increase-turn-no))))

(declare handle-ai-actions)

(defn advance-turn-phase [state]
  (let [advance-fn (fn [m] (let [turn-phase (:turn-phase m)
                                 next-phase (case turn-phase
                                              :designated-move :optional-move
                                              :optional-move :select-opponent-piece
                                              :select-opponent-piece :designated-move)
                                 last-turn (= turn-phase :select-opponent-piece)]
                             (cond-> m
                               :always (assoc :turn-phase next-phase)
                               last-turn change-turn)))]
    (-> state
        advance-fn
        handle-ai-actions)))

(defn move-pawn [state x y]
  (let [{:keys [pawns selected-pawn]} state
        new-pos (get-valid-tile x y selected-pawn pawns)]
    (if new-pos
      (let [[color id] selected-pawn
            new-state (-> state
                          (assoc-in [:pawns color id] new-pos)
                          (assoc :last-moved-pawn selected-pawn)
                          (assoc :selected-pawn nil)
                          (assoc :fixed-pawn nil)
                          (check-winning-pawn)
                          (advance-turn-phase))]
        new-state)
      state)))

;; TODO -animation should start sooner, dunno what to do exactly here!
(defn pawn-widget [color selected?]
  (let [opacity (atom 1.0)
        fcolor (if (= color :white) m/Colors.green.shade600 m/Colors.black)
        toggle-opacity (fn [] (swap! opacity #(if (= % 1.0) 0.0 1.0)))]
    (when selected? (async/Timer.periodic
                     (sched/Duration. .milliseconds 500)
                     (fn [timer]
                       (toggle-opacity)
                       (when (not selected?) (.cancel ^async/Timer timer)))))
    (f/widget
     :watch [opacity opacity]
     (w/Container
      .width cell-size
      .height cell-size
      .child
      (w/Center
       .child
       (w/Stack
        .alignment m/Alignment.center
        .children
        [(w/Container
          .width (- cell-size 8)
          .height (-  cell-size 8)
          .color (if selected? m/Colors.blue fcolor))
         (w/AnimatedOpacity
          .opacity opacity
          .duration (sched/Duration. .milliseconds 500)
          .child (w/Container
                  .width (- cell-size 8)
                  .height (- cell-size 8)
                  .color fcolor))]))))))

(defn message-box []
  (f/widget
   :watch [s state]
   (let [{:keys [current-player turn-phase pawns selected-pawn fixed-pawn winner-pawn
                 last-moved-pawn turn-no turn-finished]} s]
     (m/Card
      .elevation 8
      .margin (w/EdgeInsets.all 16)
      .child (w/Text
              (str "Current Player: " (name current-player)
                   "\nTurn Phase: " turn-phase
                   "\nSelected Pawn: " selected-pawn
                   "\n Last Moved Pawn: " last-moved-pawn
                   "\nFixed Pawn:" fixed-pawn
                   "\nPositions W: " (:white pawns)
                   "\nPositions B:" (:black pawns)
                   "\nFinished: " turn-finished
                   "\nTurn Number:" turn-no
                   "\nWinner Pawn: " winner-pawn
                   "\nValid Moves: " (when selected-pawn
                                       (apply #(get-valid-moves pawns %1 %2)
                                              (get-in pawns selected-pawn))))
              .style (w/TextStyle
                      .fontSize 18
                      .fontWeight w/FontWeight.bold))))))

(defn first-turn-rule-white? [current-player turn-no turn-phase id]
  (if (and (= turn-no 1) (= current-player :white) (= turn-phase :designated-move))
    (= id :b)
    true))

(defn last-and-to-be-selected-different? [state selected]
  (not= (:last-moved-pawn state) selected))

(defn select-pawn [state color id]
  (let [{:keys [current-player turn-no turn-phase fixed-pawn]} state]
    (if-not fixed-pawn
      (cond
        (and (= turn-phase :select-opponent-piece)
             (not= current-player color))
        (-> state
            (assoc :selected-pawn [color id])
            (assoc :fixed-pawn [color id])
            (remove-blocked-pawn)
            (advance-turn-phase))

        (and (= current-player color)
             (#{:designated-move :optional-move} turn-phase)
             (last-and-to-be-selected-different? state [color id])
             (first-turn-rule-white? current-player turn-no turn-phase id))
        (assoc state :selected-pawn [color id])

        :else state)
      state)))

;; Let's program AI...
;; W1 : B1 -> B2
;;    : (random selection & movement)
;;    : (random selection of opponent piece)
;; B1 : (selected pawn) -> one field up
;;    : (random selection & movement)
;;    : (if blocked - select; if blocking winning pos - select ; if near opponent's winning pos and must move backward - select ; random selection)
;; W2 : move in direct of winning position
;;    : select nearest pawn (to winning pos) and move it; skip turn if it would create a blocked pawn on our side
;;    : (if blocked - select; if blocking winning pos - select ; if near opponent's winning pos and must move backward - select ; random selection)
;; .....
(defn ai-select-pawn [state]
  (let [{:keys [ai-player pawns last-moved-pawn]} state
        pawns (get pawns ai-player)
        [color id] last-moved-pawn
        last-moved-id (when (= ai-player color) id)
        id (rand-nth (disj (set (keys pawns)) last-moved-id))]
    (assoc state :selected-pawn [:black id])))

(defn ai-move-pawn [state]
  (if-let [selected-pawn (:selected-pawn state)]
    (let [{:keys [pawns]} state
          [sx sy] (get-in pawns selected-pawn)
          valid-moves (get-valid-moves pawns sx sy)
          [x y] (rand-nth valid-moves)]
      (move-pawn state x y))
    state))

(defn ai-select-opponent-pawn [state]
  (let [pawns (get-in state [:pawns :white])
        [id pos] (rand-nth (seq pawns))]
    (select-pawn state :white id)))

;; TODO - Jakmile vymazu figurku, prestane to fungovat!
;; TODO - na dobre ceste, ale asi to bude treba muset zpomalit nebo neco :-D
(defn handle-ai-actions [state]
  (let [{:keys [current-player turn-phase ai-enabled selected-pawn]} state]
    (if (and ai-enabled (= current-player :black))
      (case turn-phase
        :designated-move (if (vector? selected-pawn)
                           (ai-move-pawn state)
                           (-> state (ai-select-pawn) (ai-move-pawn)))
        :optional-move (-> state (ai-select-pawn) (ai-move-pawn))
        :select-opponent-piece (ai-select-opponent-pawn state)
        state)
      state)))

;; END OF AI

(defn first-turn-rule-black? [turn-no turn-phase]
  (and (not= turn-no 1) (= turn-phase :optional-move)))

(defn skip-turn-button [state]
  (m/TextButton
   .onPressed #(swap! state advance-turn-phase)
   .child (m/Text "Skip turn!")))

(defn reset-game-button [state]
  (m/TextButton
   .onPressed #(reset! state initial-state)
   .child (m/Text "Reset game!")))

(defn board-widget []
  (f/widget
   :watch [s state]
   (let [{:keys [pawns selected-pawn turn-no turn-phase]} s
         [selected-color selected-id] selected-pawn]
     (w/Container
      .width 640 ;;240 without box
      .height 500
      .child
      (m/Column
       .children
       [(m/Row
         .children
         [(w/Stack
           .children
           (apply conj
                  [(m/Row
                    .children
                    (for [x (range board-size-x)]
                      (m/Column
                       .children
                       (for [y (range board-size-y)]
                         (w/GestureDetector
                          .onTap #(when selected-pawn
                                    (swap! state move-pawn x y))
                          .child (cell-widget [x y]))))))]
                  (for [[color positions] pawns
                        [id [x y]] positions]
                    (let [selected? (and (= selected-color color)
                                         (= selected-id id))]
                      (f/widget
                       :key (str color "-" id)
                       (w/AnimatedPositioned
                        .left (* x cell-size)
                        .top (* y cell-size)
                        .duration (m/Duration. .seconds 1)
                        .child (w/GestureDetector
                                .onTap #(swap! state select-pawn color id)
                                .child (pawn-widget color selected?))))))))
          (message-box)])
        (if (first-turn-rule-black? turn-no turn-phase)
          (skip-turn-button state)
          (w/Container))
        (reset-game-button state)])))))

(defn main []
  (reset! state initial-state)
  (f/run
   (m/MaterialApp
    .title "Hupo"
    .home (m/Scaffold
           .appBar (m/AppBar .title (m/Text "Hra"))
           .body  (m/Center
                   .child
                   (board-widget))))))
